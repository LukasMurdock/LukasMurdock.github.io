---
layout: post
title: 'CMS'
description: 'The future of document authoring.'
date: 'March 25, 2022'
---

Preface: I know very little about data structures and only have experience primarily writing TypeScript over the past two years.

---

There are three steps in a document lifecycle:
1. Document editing/authoring
2. Publication
3. Subscription

Social network platforms took over the web in part due to providing better default solutions to document editing, publication, and subscription than the web.

## The Web Protocols
- Document editing: HTML
- Document Publication: Atom, RSS 2.0
- Document Subscription: Atom, RSS 2.0



Feeds in the form of Atom are wonderful. However, companies don‘t want you to use them, instead they want you to:
1. [CONSUME INCESSANTLY](https://www.wired.com/2013/06/why-google-reader-got-the-ax/#:~:text=Google%20wants%20its%20readers%20to%20take%20this%20more%20active%20approach%20to%20news%20consumption.)
2. Give them [more data](https://www.wired.com/2013/06/why-google-reader-got-the-ax/#:~:text=data%20like%20your%20location%2C%20the%20time%20of%20day%2C%20and%20whether%20you%E2%80%99re%20stationary%20or%20on%20the%20road)

But, the default document editing experience (HTML) is garbage compared to the interfaces provided by social networks—most everyone will never pick HTML as a document editing experience.

[Markdown](https://daringfireball.net/projects/markdown/) took off as the primary document experience by providing an “easy-to-read, easy-to-write plain text format” that would be converted to structurally valid HTML. Markdown is remarkably pervasive in tech-oriented places.

Historically, “plain text” was optimal for a few reasons:
1. Interoperability
	- It’s simple to process and a timeless format—guaranteeing readability ten years from now
2. Quick, easy, distraction-less authoring
3. Distributed access (access across applications or systems)
	- Easy distribution means easy ownership

[Rich-text format](https://en.wikipedia.org/wiki/Rich_Text_Format) is a data format for saving and sharing documents—now supported by most word processing software.

While the web has protocols for publication and subscription (Feeds in the form of Atom or RSS 2.0), the default document editing/authoring experience is HTML—garbage compared to the interfaces provided by social networks. Markdown

Sidenote: Atom (Syndication Format and Publishing Protocol) should be renamed to Follow, Subscribe, Collection, or Feed protocol. [Atom > RSS](https://danielmiessler.com/blog/atom-rss-why-we-should-just-call-them-feeds-instead-of-rss-feeds/).

## Stages of document authoring

1. **Past:** Local-first and offline Word document editing, send document back and forth with comments for changes.
2. **Present:** Online-only real-time document collaboration with [Google Docs](https://www.google.com/docs/about/) and [Word for the web](https://www.microsoft.com/en-us/microsoft-365/free-office-online-for-the-web). Local-first documents with [bad syncing issues](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals). And the document is separate from any form of publishing.
3. **Future:** Offline [Local-first](https://www.inkandswitch.com/local-first/) document collaboration with online real-time capabilities, custom block editing, and publishing.

The future is powered by Conflict-free Replicated Data Types (CRDTs).

## Conflict-free Replicated Data Types (CRDTs)

TL;DR two people editing on the same document means *conflicting edits*. Conflict-free Replicated Data Types (CRDTs) provide an easy way to handle said conflicts.

CRDT Resources:
- [CRDT.tech](https://crdt.tech/)
- [Ink & Switch](https://www.inkandswitch.com/)
- [A CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/)
- [CRDTs for mortals](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals) (Video)
- [CRDTs: the hard parts](https://martin.kleppmann.com/2020/07/06/crdt-hard-parts-hydra.html)

## Problems with future document authoring
- ✅ Real-time communication for the web ([WebRTC](https://webrtc.org/))
- ✅ Data type for real-time rich-text editing ([CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/))
- 🚧 Data type for real-time custom block editing ([gh issue](https://github.com/inkandswitch/peritext/issues/27))
- ❓ Persistent storage for the web ([IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API))

## Data type for real-time rich-text editing 

---

### CRDT rich-text editing resources
- [Peritext: CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/)
- [yjs](https://github.com/yjs/yjs)

---

Operations: insert, remove, addMark, removeMark.

1. Create event sourcing format
2. Turn events into a proper document display

```javascript
[
  { char: "T", opId: "9@B", deleted: false, markOpsBefore: [
    {
      action: "addMark",
      opId: "19@A",
      start: { type: "before", opId: "9@B" },
      end:   { type: "before", opId: "10@B" },
      markType: "bold"
    }
  ] },
  { char: "t", opId: "1@A", deleted: true },
  { char: "h", opId: "2@A", deleted: false },
  { char: "e", opId: "3@A", deleted: false },
  { char: " ", opId: "4@A", deleted: false },
  { char: "f", opId: "5@A", deleted: false },
  { char: "o", opId: "6@A", deleted: false },
  { char: "x", opId: "7@A", deleted: false },
  { char: " ", opId: "10@B", deleted: false, markOpsBefore: [] },
  …
]
```

Iterate over character list and convert each set of mark operations to the corresponding formatted span.

```javascript
[
  { text: "The ",     format: { bold: true } },
  { text: "fox",      format: { bold: true, italic: true } },
  { text: " jumped.", format: { italic: true } }
]
```


When an operation is applied:
1. Updating internal document state
2. Compute a patch describing how the operation affects the text editor document state


```javascript
// a patch to insert the letter “x” at index 6 with bold formatting might look like this
{
  type: "insert",
  char: "x",
  index: 6,
  format: { bold: true }
}
```

## Data type for real-time block editing
- [Peritext block elements issue](https://github.com/inkandswitch/peritext/issues/27)

Again, I don’t even know what I don‘t know about data structures.

However, my thinking is to lean into ASTs in the unified [Universal Syntax Tree](https://github.com/syntax-tree/unist) format.


```typescript
interface Node {
  type: string
  data: Data?
  position: Position?
}

interface Position {
  start: Point
  end: Point
  indent: [number >= 1]?
}

interface Point {
  line: number >= 1
  column: number >= 1
  offset: number >= 0?
}
```
	
### Block editing resources
- [Unified](https://unifiedjs.com/) (ASTs)
- [atjson](https://github.com/CondeNast/atjson)
- [Block protocol](https://blockprotocol.org/)
- [WordPress Block Editor](https://developer.wordpress.org/block-editor/reference-guides/block-api/)
- [Excalidraw P2P Collaboration](https://blog.excalidraw.com/building-excalidraw-p2p-collaboration-feature/)

