---
layout: post
title: 'CMS'
description: 'The future of document authoring.'
date: 'March 25, 2022'
---

Preface: I know very little about data structures and only have experience primarily writing TypeScript over the past two years.

## Stages of document authoring

1. **Past:** Local-first and offline Word document editing, send document back and forth with comments for changes.
2. **Present:** Online-only real-time document collaboration with [Google Docs](https://www.google.com/docs/about/) and [Word for the web](https://www.microsoft.com/en-us/microsoft-365/free-office-online-for-the-web). Local-first documents with [bad syncing issues](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals). And the document is separate from any form of publishing.
3. **Future:** Offline [Local-first](https://www.inkandswitch.com/local-first/) document collaboration with online real-time capabilities, custom block editing, and publishing.

The future is powered by Conflict-free Replicated Data Types (CRDTs).

## Conflict-free Replicated Data Types (CRDTs)

TL;DR two people editing on the same document means *conflicting edits*. Conflict-free Replicated Data Types (CRDTs) provide an easy way to handle said conflicts.

CRDT Resources:
- [CRDT.tech](https://crdt.tech/)
- [Ink & Switch](https://www.inkandswitch.com/)
- [A CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/)
- [CRDTs for mortals](https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals) (Video)
- [CRDTs: the hard parts](https://martin.kleppmann.com/2020/07/06/crdt-hard-parts-hydra.html)

## Problems with future document authoring
- ✅ Real-time communication for the web ([WebRTC](https://webrtc.org/))
- ✅ Data type for real-time rich-text editing ([CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/))
- 🚧 Data type for real-time custom block editing ([gh issue](https://github.com/inkandswitch/peritext/issues/27))
- ❓ Persistent storage for the web ([IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API))

## Data type for real-time rich-text editing 

---

### CRDT rich-text editing resources
- [Peritext: CRDT for Rich-Text Collaboration](https://www.inkandswitch.com/peritext/)
- [yjs](https://github.com/yjs/yjs)

---

Operations: insert, remove, addMark, removeMark.

1. Create event sourcing format
2. Turn events into a proper document display

```javascript
[
  { char: "T", opId: "9@B", deleted: false, markOpsBefore: [
    {
      action: "addMark",
      opId: "19@A",
      start: { type: "before", opId: "9@B" },
      end:   { type: "before", opId: "10@B" },
      markType: "bold"
    }
  ] },
  { char: "t", opId: "1@A", deleted: true },
  { char: "h", opId: "2@A", deleted: false },
  { char: "e", opId: "3@A", deleted: false },
  { char: " ", opId: "4@A", deleted: false },
  { char: "f", opId: "5@A", deleted: false },
  { char: "o", opId: "6@A", deleted: false },
  { char: "x", opId: "7@A", deleted: false },
  { char: " ", opId: "10@B", deleted: false, markOpsBefore: [] },
  …
]
```

Iterate over character list and convert each set of mark operations to the corresponding formatted span.

```javascript
[
  { text: "The ",     format: { bold: true } },
  { text: "fox",      format: { bold: true, italic: true } },
  { text: " jumped.", format: { italic: true } }
]
```


When an operation is applied:
1. Updating internal document state
2. Compute a patch describing how the operation affects the text editor document state


```javascript
// a patch to insert the letter “x” at index 6 with bold formatting might look like this
{
  type: "insert",
  char: "x",
  index: 6,
  format: { bold: true }
}
```

## Data type for real-time block editing
- [Peritext block elements issue](https://github.com/inkandswitch/peritext/issues/27)

Again, I don’t even know what I don‘t know about data structures.

However, my thinking is to lean into ASTs in the unified [Universal Syntax Tree](https://github.com/syntax-tree/unist) format.


```typescript
interface Node {
  type: string
  data: Data?
  position: Position?
}

interface Position {
  start: Point
  end: Point
  indent: [number >= 1]?
}

interface Point {
  line: number >= 1
  column: number >= 1
  offset: number >= 0?
}
```

### Block editing resources
- [Unified](https://unifiedjs.com/) (ASTs)
- [atjson](https://github.com/CondeNast/atjson)
- [Block protocol](https://blockprotocol.org/)
- [WordPress Block Editor](https://developer.wordpress.org/block-editor/reference-guides/block-api/)

